"""
Tim在学习二维列表时，盯着电脑键盘发呆，发现自己的电脑键盘很像是国际象棋棋盘。于是他便做了一场梦。
梦里，一位老人拿出了一个矩形国际象棋棋盘。他在棋盘的左上角摆了一个“卫士”，“卫士”每次行棋能且仅能向棋盘的下方或右方移动一格。
那位老人随机在棋盘的右下角摆了一块金粒，告诉Tim他能找到多少条能让“卫士”从左上角移动到右下角的可行路径，他就会给Tim多少块一样的金粒。
然而，老人不想让游戏变得太简单。他在棋盘上放了一块石头，使得“卫士”无法移动到有石头的格子上。老人拂袖离去，只留下Tim在原地思索。
...
正在Tim一条条推演路径之时，对面的座位上忽然出现了一位年轻人，Tim一眼就认出那是印度数学家拉马努金。
拉马努金嘴里念念有词，听起来像是古印度语，Tim并不知道其中含义。不久，拉马努金在一团烟雾中消失了。
这时，Tim猛然注意到：设dp(G)为“卫士”从棋盘左上角移动到格子G的可行路径总数量，则对于棋盘上的每个格子，都有dp(G)=dp(G上面的格子)+F(G左边的格子)！
经过一番思索，Tim验证了这个结论的正确性。这真是一个伟大的发现。
然而，Tim不知道怎么进行进一步计算。他认为二维列表可能对此有帮助。

请你设计一个 Python 程序，帮助Tim计算他能获得的最多金粒数量，即“卫士”从左上角不经过石头移动到右下角的可行路径总数。

输入：
    两行，每行一个整数，分别表示棋盘的行数和列数n、m。
    两行，每行一个整数，分别表示石头所在的行和列a、b（第一行为1、第一列为1）。
    保证石头不在起点或终点。
输出：
    一行，一个整数，表示Tim最多能获得的金粒总数。
"""
dp = []
n = int(input())
m = int(input())
a = int(input())
b = int(input())

voidrow = []
for i in range(m+1):
    voidrow.append(0)
for i in range(n+1):
    dp.append(voidrow)
dp[0][1] = 1

for i in range(n):
    for j in range(m):
        if i == a-1 and j == b-1:
            dp[i+1][j+1] = 0
        else:
            dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1]

print(dp[n][m])